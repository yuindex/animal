{"version":3,"sources":["index.js","backend.js","binding.js","version.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.listSupportedBackends = void 0;\n__exportStar(require(\"onnxruntime-common\"), exports);\nvar backend_1 = require(\"./backend\");\nObject.defineProperty(exports, \"listSupportedBackends\", { enumerable: true, get: function () { return backend_1.listSupportedBackends; } });\nconst onnxruntime_common_1 = require(\"onnxruntime-common\");\nconst version_1 = require(\"./version\");\nconst backend_2 = require(\"./backend\");\nconst backends = (0, backend_2.listSupportedBackends)();\nfor (const backend of backends) {\n    (0, onnxruntime_common_1.registerBackend)(backend.name, backend_2.onnxruntimeBackend, 100);\n}\nObject.defineProperty(onnxruntime_common_1.env.versions, 'node', { value: version_1.version, enumerable: true });\n//# sourceMappingURL=index.js.map","\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _OnnxruntimeSessionHandler_inferenceSession;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.listSupportedBackends = exports.onnxruntimeBackend = void 0;\nconst binding_1 = require(\"./binding\");\nclass OnnxruntimeSessionHandler {\n    constructor(pathOrBuffer, options) {\n        _OnnxruntimeSessionHandler_inferenceSession.set(this, void 0);\n        __classPrivateFieldSet(this, _OnnxruntimeSessionHandler_inferenceSession, new binding_1.binding.InferenceSession(), \"f\");\n        if (typeof pathOrBuffer === 'string') {\n            __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, \"f\").loadModel(pathOrBuffer, options);\n        }\n        else {\n            __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, \"f\").loadModel(pathOrBuffer.buffer, pathOrBuffer.byteOffset, pathOrBuffer.byteLength, options);\n        }\n        this.inputNames = __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, \"f\").inputNames;\n        this.outputNames = __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, \"f\").outputNames;\n    }\n    async dispose() {\n        __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, \"f\").dispose();\n    }\n    startProfiling() {\n        // TODO: implement profiling\n    }\n    endProfiling() {\n        // TODO: implement profiling\n    }\n    async run(feeds, fetches, options) {\n        return new Promise((resolve, reject) => {\n            process.nextTick(() => {\n                try {\n                    resolve(__classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, \"f\").run(feeds, fetches, options));\n                }\n                catch (e) {\n                    // reject if any error is thrown\n                    reject(e);\n                }\n            });\n        });\n    }\n}\n_OnnxruntimeSessionHandler_inferenceSession = new WeakMap();\nclass OnnxruntimeBackend {\n    async init() {\n        return Promise.resolve();\n    }\n    async createInferenceSessionHandler(pathOrBuffer, options) {\n        return new Promise((resolve, reject) => {\n            process.nextTick(() => {\n                try {\n                    resolve(new OnnxruntimeSessionHandler(pathOrBuffer, options || {}));\n                }\n                catch (e) {\n                    // reject if any error is thrown\n                    reject(e);\n                }\n            });\n        });\n    }\n}\nexports.onnxruntimeBackend = new OnnxruntimeBackend();\nexports.listSupportedBackends = binding_1.binding.listSupportedBackends;\n//# sourceMappingURL=backend.js.map","\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.binding = void 0;\n// export native binding\nexports.binding = \n// eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\nrequire(`../bin/napi-v3/${process.platform}/${process.arch}/onnxruntime_binding.node`);\n//# sourceMappingURL=binding.js.map","\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = void 0;\n// This file is generated by /js/scripts/update-version.ts\n// Do not modify file content manually.\nexports.version = '1.17.0';\n//# sourceMappingURL=version.js.map"]}